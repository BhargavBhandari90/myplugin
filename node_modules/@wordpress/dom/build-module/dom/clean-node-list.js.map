{"version":3,"sources":["@wordpress/dom/src/dom/clean-node-list.js"],"names":["includes","isEmpty","remove","unwrap","isPhrasingContent","insertAfter","isElement","noop","cleanNodeList","nodeList","doc","schema","inline","Array","from","forEach","node","tag","nodeName","toLowerCase","hasOwnProperty","isMatch","attributes","classes","children","require","allowEmpty","hasAttributes","name","removeAttribute","classList","length","mattchers","map","item","className","RegExp","test","some","hasChildNodes","querySelector","join","childNodes","parentNode","child","firstChild","nextElementSibling","createElement"],"mappings":"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","sourcesContent":["/**\n * External dependencies\n */\nimport { includes } from 'lodash';\n\n/**\n * Internal dependencies\n */\nimport isEmpty from './is-empty';\nimport remove from './remove';\nimport unwrap from './unwrap';\nimport { isPhrasingContent } from '../phrasing-content';\nimport insertAfter from './insert-after';\nimport isElement from './is-element';\n\nconst noop = () => {};\n\n/* eslint-disable jsdoc/valid-types */\n/**\n * @typedef SchemaItem\n * @property {string[]}                            [attributes] Attributes.\n * @property {(string | RegExp)[]}                 [classes]    Classnames or RegExp to test against.\n * @property {'*' | { [tag: string]: SchemaItem }} [children]   Child schemas.\n * @property {string[]}                            [require]    Selectors to test required children against. Leave empty or undefined if there are no requirements.\n * @property {boolean}                             allowEmpty   Whether to allow nodes without children.\n * @property {(node: Node) => boolean}             [isMatch]    Function to test whether a node is a match. If left undefined any node will be assumed to match.\n */\n\n/** @typedef {{ [tag: string]: SchemaItem }} Schema */\n/* eslint-enable jsdoc/valid-types */\n\n/**\n * Given a schema, unwraps or removes nodes, attributes and classes on a node\n * list.\n *\n * @param {NodeList} nodeList The nodeList to filter.\n * @param {Document} doc      The document of the nodeList.\n * @param {Schema}   schema   An array of functions that can mutate with the provided node.\n * @param {boolean}  inline   Whether to clean for inline mode.\n */\nexport default function cleanNodeList( nodeList, doc, schema, inline ) {\n\tArray.from( nodeList ).forEach(\n\t\t( /** @type {Node & { nextElementSibling?: unknown }} */ node ) => {\n\t\t\tconst tag = node.nodeName.toLowerCase();\n\n\t\t\t// It's a valid child, if the tag exists in the schema without an isMatch\n\t\t\t// function, or with an isMatch function that matches the node.\n\t\t\tif (\n\t\t\t\tschema.hasOwnProperty( tag ) &&\n\t\t\t\t( ! schema[ tag ].isMatch || schema[ tag ].isMatch?.( node ) )\n\t\t\t) {\n\t\t\t\tif ( isElement( node ) ) {\n\t\t\t\t\tconst {\n\t\t\t\t\t\tattributes = [],\n\t\t\t\t\t\tclasses = [],\n\t\t\t\t\t\tchildren,\n\t\t\t\t\t\trequire = [],\n\t\t\t\t\t\tallowEmpty,\n\t\t\t\t\t} = schema[ tag ];\n\n\t\t\t\t\t// If the node is empty and it's supposed to have children,\n\t\t\t\t\t// remove the node.\n\t\t\t\t\tif ( children && ! allowEmpty && isEmpty( node ) ) {\n\t\t\t\t\t\tremove( node );\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( node.hasAttributes() ) {\n\t\t\t\t\t\t// Strip invalid attributes.\n\t\t\t\t\t\tArray.from( node.attributes ).forEach( ( { name } ) => {\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\tname !== 'class' &&\n\t\t\t\t\t\t\t\t! includes( attributes, name )\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tnode.removeAttribute( name );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t// Strip invalid classes.\n\t\t\t\t\t\t// In jsdom-jscore, 'node.classList' can be undefined.\n\t\t\t\t\t\t// TODO: Explore patching this in jsdom-jscore.\n\t\t\t\t\t\tif ( node.classList && node.classList.length ) {\n\t\t\t\t\t\t\tconst mattchers = classes.map( ( item ) => {\n\t\t\t\t\t\t\t\tif ( typeof item === 'string' ) {\n\t\t\t\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t\t\t\t/** @type {string} */ className\n\t\t\t\t\t\t\t\t\t) => className === item;\n\t\t\t\t\t\t\t\t} else if ( item instanceof RegExp ) {\n\t\t\t\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t\t\t\t/** @type {string} */ className\n\t\t\t\t\t\t\t\t\t) => item.test( className );\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\treturn noop;\n\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t\tArray.from( node.classList ).forEach( ( name ) => {\n\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t! mattchers.some( ( isMatch ) =>\n\t\t\t\t\t\t\t\t\t\tisMatch( name )\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\tnode.classList.remove( name );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t\tif ( ! node.classList.length ) {\n\t\t\t\t\t\t\t\tnode.removeAttribute( 'class' );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( node.hasChildNodes() ) {\n\t\t\t\t\t\t// Do not filter any content.\n\t\t\t\t\t\tif ( children === '*' ) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Continue if the node is supposed to have children.\n\t\t\t\t\t\tif ( children ) {\n\t\t\t\t\t\t\t// If a parent requires certain children, but it does\n\t\t\t\t\t\t\t// not have them, drop the parent and continue.\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\trequire.length &&\n\t\t\t\t\t\t\t\t! node.querySelector( require.join( ',' ) )\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tcleanNodeList(\n\t\t\t\t\t\t\t\t\tnode.childNodes,\n\t\t\t\t\t\t\t\t\tdoc,\n\t\t\t\t\t\t\t\t\tschema,\n\t\t\t\t\t\t\t\t\tinline\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tunwrap( node );\n\t\t\t\t\t\t\t\t// If the node is at the top, phrasing content, and\n\t\t\t\t\t\t\t\t// contains children that are block content, unwrap\n\t\t\t\t\t\t\t\t// the node because it is invalid.\n\t\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\t\tnode.parentNode &&\n\t\t\t\t\t\t\t\tnode.parentNode.nodeName === 'BODY' &&\n\t\t\t\t\t\t\t\tisPhrasingContent( node )\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tcleanNodeList(\n\t\t\t\t\t\t\t\t\tnode.childNodes,\n\t\t\t\t\t\t\t\t\tdoc,\n\t\t\t\t\t\t\t\t\tschema,\n\t\t\t\t\t\t\t\t\tinline\n\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\tArray.from( node.childNodes ).some(\n\t\t\t\t\t\t\t\t\t\t( child ) =>\n\t\t\t\t\t\t\t\t\t\t\t! isPhrasingContent( child )\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\tunwrap( node );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tcleanNodeList(\n\t\t\t\t\t\t\t\t\tnode.childNodes,\n\t\t\t\t\t\t\t\t\tdoc,\n\t\t\t\t\t\t\t\t\tchildren,\n\t\t\t\t\t\t\t\t\tinline\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// Remove children if the node is not supposed to have any.\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\twhile ( node.firstChild ) {\n\t\t\t\t\t\t\t\tremove( node.firstChild );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Invalid child. Continue with schema at the same place and unwrap.\n\t\t\t} else {\n\t\t\t\tcleanNodeList( node.childNodes, doc, schema, inline );\n\n\t\t\t\t// For inline mode, insert a line break when unwrapping nodes that\n\t\t\t\t// are not phrasing content.\n\t\t\t\tif (\n\t\t\t\t\tinline &&\n\t\t\t\t\t! isPhrasingContent( node ) &&\n\t\t\t\t\tnode.nextElementSibling\n\t\t\t\t) {\n\t\t\t\t\tinsertAfter( doc.createElement( 'br' ), node );\n\t\t\t\t}\n\n\t\t\t\tunwrap( node );\n\t\t\t}\n\t\t}\n\t);\n}\n"]}