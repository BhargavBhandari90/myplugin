{"version":3,"sources":["@wordpress/dom/src/dom/is-edge.js"],"names":["isEdge","container","isReverse","onlyVertical","selectionStart","selectionEnd","value","length","isContentEditable","ownerDocument","defaultView","selection","getSelection","rangeCount","range","getRangeAt","collapsedRange","cloneRange","isForward","isCollapsed","collapse","collapsedRangeRect","rangeRect","rangeHeight","height","isReverseDir","containerRect","getBoundingClientRect","x","left","right","y","top","bottom","testRange","testRect","verticalSide","horizontalSide","verticalDiff","horizontalDiff","hasVerticalDiff","Math","abs","hasHorizontalDiff"],"mappings":"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","sourcesContent":["/**\n * Internal dependencies\n */\nimport isRTL from './is-rtl';\nimport getRangeHeight from './get-range-height';\nimport getRectangleFromRange from './get-rectangle-from-range';\nimport isSelectionForward from './is-selection-forward';\nimport hiddenCaretRangeFromPoint from './hidden-caret-range-from-point';\nimport { assertIsDefined } from '../utils/assert-is-defined';\nimport isInputOrTextArea from './is-input-or-text-area';\n\n/**\n * Check whether the selection is at the edge of the container. Checks for\n * horizontal position by default. Set `onlyVertical` to true to check only\n * vertically.\n *\n * @param {Element} container            Focusable element.\n * @param {boolean} isReverse            Set to true to check left, false to check right.\n * @param {boolean} [onlyVertical=false] Set to true to check only vertical position.\n *\n * @return {boolean} True if at the edge, false if not.\n */\nexport default function isEdge( container, isReverse, onlyVertical = false ) {\n\tif (\n\t\tisInputOrTextArea( container ) &&\n\t\ttypeof container.selectionStart === 'number'\n\t) {\n\t\tif ( container.selectionStart !== container.selectionEnd ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( isReverse ) {\n\t\t\treturn container.selectionStart === 0;\n\t\t}\n\n\t\treturn container.value.length === container.selectionStart;\n\t}\n\n\tif ( ! ( /** @type {HTMLElement} */ ( container ).isContentEditable ) ) {\n\t\treturn true;\n\t}\n\n\tconst { ownerDocument } = container;\n\tconst { defaultView } = ownerDocument;\n\n\tassertIsDefined( defaultView, 'defaultView' );\n\tconst selection = defaultView.getSelection();\n\n\tif ( ! selection || ! selection.rangeCount ) {\n\t\treturn false;\n\t}\n\n\tconst range = selection.getRangeAt( 0 );\n\tconst collapsedRange = range.cloneRange();\n\tconst isForward = isSelectionForward( selection );\n\tconst isCollapsed = selection.isCollapsed;\n\n\t// Collapse in direction of selection.\n\tif ( ! isCollapsed ) {\n\t\tcollapsedRange.collapse( ! isForward );\n\t}\n\n\tconst collapsedRangeRect = getRectangleFromRange( collapsedRange );\n\tconst rangeRect = getRectangleFromRange( range );\n\n\tif ( ! collapsedRangeRect || ! rangeRect ) {\n\t\treturn false;\n\t}\n\n\t// Only consider the multiline selection at the edge if the direction is\n\t// towards the edge. The selection is multiline if it is taller than the\n\t// collapsed  selection.\n\tconst rangeHeight = getRangeHeight( range );\n\tif (\n\t\t! isCollapsed &&\n\t\trangeHeight &&\n\t\trangeHeight > collapsedRangeRect.height &&\n\t\tisForward === isReverse\n\t) {\n\t\treturn false;\n\t}\n\n\t// In the case of RTL scripts, the horizontal edge is at the opposite side.\n\tconst isReverseDir = isRTL( container ) ? ! isReverse : isReverse;\n\tconst containerRect = container.getBoundingClientRect();\n\n\t// To check if a selection is at the edge, we insert a test selection at the\n\t// edge of the container and check if the selections have the same vertical\n\t// or horizontal position. If they do, the selection is at the edge.\n\t// This method proves to be better than a DOM-based calculation for the\n\t// horizontal edge, since it ignores empty textnodes and a trailing line\n\t// break element. In other words, we need to check visual positioning, not\n\t// DOM positioning.\n\t// It also proves better than using the computed style for the vertical\n\t// edge, because we cannot know the padding and line height reliably in\n\t// pixels. `getComputedStyle` may return a value with different units.\n\tconst x = isReverseDir ? containerRect.left + 1 : containerRect.right - 1;\n\tconst y = isReverse ? containerRect.top + 1 : containerRect.bottom - 1;\n\tconst testRange = hiddenCaretRangeFromPoint(\n\t\townerDocument,\n\t\tx,\n\t\ty,\n\t\t/** @type {HTMLElement} */ ( container )\n\t);\n\n\tif ( ! testRange ) {\n\t\treturn false;\n\t}\n\n\tconst testRect = getRectangleFromRange( testRange );\n\n\tif ( ! testRect ) {\n\t\treturn false;\n\t}\n\n\tconst verticalSide = isReverse ? 'top' : 'bottom';\n\tconst horizontalSide = isReverseDir ? 'left' : 'right';\n\tconst verticalDiff = testRect[ verticalSide ] - rangeRect[ verticalSide ];\n\tconst horizontalDiff =\n\t\ttestRect[ horizontalSide ] - collapsedRangeRect[ horizontalSide ];\n\n\t// Allow the position to be 1px off.\n\tconst hasVerticalDiff = Math.abs( verticalDiff ) <= 1;\n\tconst hasHorizontalDiff = Math.abs( horizontalDiff ) <= 1;\n\n\treturn onlyVertical\n\t\t? hasVerticalDiff\n\t\t: hasVerticalDiff && hasHorizontalDiff;\n}\n"]}