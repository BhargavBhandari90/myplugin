{"version":3,"sources":["@wordpress/data/src/components/use-select/index.js"],"names":["useMemoOne","createQueue","useRef","useCallback","useMemo","useReducer","isShallowEqual","useIsomorphicLayoutEffect","useRegistry","useAsyncMode","noop","renderQueue","useSelect","mapSelect","deps","hasMappingFunction","callbackMapper","_mapSelect","registry","isAsync","latestRegistry","latestMapSelect","latestIsAsync","latestMapOutput","latestMapOutputError","listeningStores","wrapSelect","callback","__unstableMarkListeningStores","select","depsChangedFlag","mapOutput","current","hasReplacedRegistry","hasReplacedMapSelect","hasLeftAsyncMode","lastMapSelectFailed","error","errorMessage","message","stack","console","undefined","queueContext","queue","forceRender","s","isMounted","onStoreChange","newMapOutput","onChange","add","unsubscribers","map","storeName","__unstableSubscribeStore","forEach","unsubscribe","cancel","useSuspenseSelect","suspendSelect","mapOutputError"],"mappings":"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","sourcesContent":["/**\n * External dependencies\n */\nimport { useMemoOne } from 'use-memo-one';\n\n/**\n * WordPress dependencies\n */\nimport { createQueue } from '@wordpress/priority-queue';\nimport { useRef, useCallback, useMemo, useReducer } from '@wordpress/element';\nimport isShallowEqual from '@wordpress/is-shallow-equal';\nimport { useIsomorphicLayoutEffect } from '@wordpress/compose';\n\n/**\n * Internal dependencies\n */\nimport useRegistry from '../registry-provider/use-registry';\nimport useAsyncMode from '../async-mode-provider/use-async-mode';\n\nconst noop = () => {};\nconst renderQueue = createQueue();\n\n/** @typedef {import('../../types').StoreDescriptor} StoreDescriptor */\n\n/**\n * Custom react hook for retrieving props from registered selectors.\n *\n * In general, this custom React hook follows the\n * [rules of hooks](https://reactjs.org/docs/hooks-rules.html).\n *\n * @param {Function|StoreDescriptor|string} mapSelect Function called on every state change. The\n *                                                    returned value is exposed to the component\n *                                                    implementing this hook. The function receives\n *                                                    the `registry.select` method on the first\n *                                                    argument and the `registry` on the second\n *                                                    argument.\n *                                                    When a store key is passed, all selectors for\n *                                                    the store will be returned. This is only meant\n *                                                    for usage of these selectors in event\n *                                                    callbacks, not for data needed to create the\n *                                                    element tree.\n * @param {Array}                           deps      If provided, this memoizes the mapSelect so the\n *                                                    same `mapSelect` is invoked on every state\n *                                                    change unless the dependencies change.\n *\n * @example\n * ```js\n * import { useSelect } from '@wordpress/data';\n *\n * function HammerPriceDisplay( { currency } ) {\n *   const price = useSelect( ( select ) => {\n *     return select( 'my-shop' ).getPrice( 'hammer', currency )\n *   }, [ currency ] );\n *   return new Intl.NumberFormat( 'en-US', {\n *     style: 'currency',\n *     currency,\n *   } ).format( price );\n * }\n *\n * // Rendered in the application:\n * // <HammerPriceDisplay currency=\"USD\" />\n * ```\n *\n * In the above example, when `HammerPriceDisplay` is rendered into an\n * application, the price will be retrieved from the store state using the\n * `mapSelect` callback on `useSelect`. If the currency prop changes then\n * any price in the state for that currency is retrieved. If the currency prop\n * doesn't change and other props are passed in that do change, the price will\n * not change because the dependency is just the currency.\n *\n * When data is only used in an event callback, the data should not be retrieved\n * on render, so it may be useful to get the selectors function instead.\n *\n * **Don't use `useSelect` this way when calling the selectors in the render\n * function because your component won't re-render on a data change.**\n *\n * ```js\n * import { useSelect } from '@wordpress/data';\n *\n * function Paste( { children } ) {\n *   const { getSettings } = useSelect( 'my-shop' );\n *   function onPaste() {\n *     // Do something with the settings.\n *     const settings = getSettings();\n *   }\n *   return <div onPaste={ onPaste }>{ children }</div>;\n * }\n * ```\n *\n * @return {Function}  A custom react hook.\n */\nexport default function useSelect( mapSelect, deps ) {\n\tconst hasMappingFunction = 'function' === typeof mapSelect;\n\n\t// If we're recalling a store by its name or by\n\t// its descriptor then we won't be caching the\n\t// calls to `mapSelect` because we won't be calling it.\n\tif ( ! hasMappingFunction ) {\n\t\tdeps = [];\n\t}\n\n\t// Because of the \"rule of hooks\" we have to call `useCallback`\n\t// on every invocation whether or not we have a real function\n\t// for `mapSelect`. we'll create this intermediate variable to\n\t// fulfill that need and then reference it with our \"real\"\n\t// `_mapSelect` if we can.\n\tconst callbackMapper = useCallback(\n\t\thasMappingFunction ? mapSelect : noop,\n\t\tdeps\n\t);\n\tconst _mapSelect = hasMappingFunction ? callbackMapper : null;\n\n\tconst registry = useRegistry();\n\tconst isAsync = useAsyncMode();\n\n\tconst latestRegistry = useRef( registry );\n\tconst latestMapSelect = useRef();\n\tconst latestIsAsync = useRef( isAsync );\n\tconst latestMapOutput = useRef();\n\tconst latestMapOutputError = useRef();\n\n\t// Keep track of the stores being selected in the _mapSelect function,\n\t// and only subscribe to those stores later.\n\tconst listeningStores = useRef( [] );\n\tconst wrapSelect = useCallback(\n\t\t( callback ) =>\n\t\t\tregistry.__unstableMarkListeningStores(\n\t\t\t\t() => callback( registry.select, registry ),\n\t\t\t\tlisteningStores\n\t\t\t),\n\t\t[ registry ]\n\t);\n\n\t// Generate a \"flag\" for used in the effect dependency array.\n\t// It's different than just using `mapSelect` since deps could be undefined,\n\t// in that case, we would still want to memoize it.\n\tconst depsChangedFlag = useMemo( () => ( {} ), deps || [] );\n\n\tlet mapOutput;\n\n\tif ( _mapSelect ) {\n\t\tmapOutput = latestMapOutput.current;\n\t\tconst hasReplacedRegistry = latestRegistry.current !== registry;\n\t\tconst hasReplacedMapSelect = latestMapSelect.current !== _mapSelect;\n\t\tconst hasLeftAsyncMode = latestIsAsync.current && ! isAsync;\n\t\tconst lastMapSelectFailed = !! latestMapOutputError.current;\n\n\t\tif (\n\t\t\thasReplacedRegistry ||\n\t\t\thasReplacedMapSelect ||\n\t\t\thasLeftAsyncMode ||\n\t\t\tlastMapSelectFailed\n\t\t) {\n\t\t\ttry {\n\t\t\t\tmapOutput = wrapSelect( _mapSelect );\n\t\t\t} catch ( error ) {\n\t\t\t\tlet errorMessage = `An error occurred while running 'mapSelect': ${ error.message }`;\n\n\t\t\t\tif ( latestMapOutputError.current ) {\n\t\t\t\t\terrorMessage += `\\nThe error may be correlated with this previous error:\\n`;\n\t\t\t\t\terrorMessage += `${ latestMapOutputError.current.stack }\\n\\n`;\n\t\t\t\t\terrorMessage += 'Original stack trace:';\n\t\t\t\t}\n\n\t\t\t\t// eslint-disable-next-line no-console\n\t\t\t\tconsole.error( errorMessage );\n\t\t\t}\n\t\t}\n\t}\n\n\tuseIsomorphicLayoutEffect( () => {\n\t\tif ( ! hasMappingFunction ) {\n\t\t\treturn;\n\t\t}\n\n\t\tlatestRegistry.current = registry;\n\t\tlatestMapSelect.current = _mapSelect;\n\t\tlatestIsAsync.current = isAsync;\n\t\tlatestMapOutput.current = mapOutput;\n\t\tlatestMapOutputError.current = undefined;\n\t} );\n\n\t// React can sometimes clear the `useMemo` cache.\n\t// We use the cache-stable `useMemoOne` to avoid\n\t// losing queues.\n\tconst queueContext = useMemoOne( () => ( { queue: true } ), [ registry ] );\n\tconst [ , forceRender ] = useReducer( ( s ) => s + 1, 0 );\n\tconst isMounted = useRef( false );\n\n\tuseIsomorphicLayoutEffect( () => {\n\t\tif ( ! hasMappingFunction ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst onStoreChange = () => {\n\t\t\ttry {\n\t\t\t\tconst newMapOutput = wrapSelect( latestMapSelect.current );\n\n\t\t\t\tif ( isShallowEqual( latestMapOutput.current, newMapOutput ) ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tlatestMapOutput.current = newMapOutput;\n\t\t\t} catch ( error ) {\n\t\t\t\tlatestMapOutputError.current = error;\n\t\t\t}\n\t\t\tforceRender();\n\t\t};\n\n\t\tconst onChange = () => {\n\t\t\tif ( ! isMounted.current ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( latestIsAsync.current ) {\n\t\t\t\trenderQueue.add( queueContext, onStoreChange );\n\t\t\t} else {\n\t\t\t\tonStoreChange();\n\t\t\t}\n\t\t};\n\n\t\t// Catch any possible state changes during mount before the subscription\n\t\t// could be set.\n\t\tonStoreChange();\n\n\t\tconst unsubscribers = listeningStores.current.map( ( storeName ) =>\n\t\t\tregistry.__unstableSubscribeStore( storeName, onChange )\n\t\t);\n\n\t\tisMounted.current = true;\n\n\t\treturn () => {\n\t\t\t// The return value of the subscribe function could be undefined if the store is a custom generic store.\n\t\t\tunsubscribers.forEach( ( unsubscribe ) => unsubscribe?.() );\n\t\t\trenderQueue.cancel( queueContext );\n\t\t\tisMounted.current = false;\n\t\t};\n\t\t// If you're tempted to eliminate the spread dependencies below don't do it!\n\t\t// We're passing these in from the calling function and want to make sure we're\n\t\t// examining every individual value inside the `deps` array.\n\t}, [ registry, wrapSelect, hasMappingFunction, depsChangedFlag ] );\n\n\treturn hasMappingFunction ? mapOutput : registry.select( mapSelect );\n}\n\n/**\n * A variant of the `useSelect` hook that has the same API, but will throw a\n * suspense Promise if any of the called selectors is in an unresolved state.\n *\n * @param {Function} mapSelect Function called on every state change. The\n *                             returned value is exposed to the component\n *                             using this hook. The function receives the\n *                             `registry.suspendSelect` method as the first\n *                             argument and the `registry` as the second one.\n * @param {Array}    deps      A dependency array used to memoize the `mapSelect`\n *                             so that the same `mapSelect` is invoked on every\n *                             state change unless the dependencies change.\n *\n * @return {Object} Data object returned by the `mapSelect` function.\n */\nexport function useSuspenseSelect( mapSelect, deps ) {\n\tconst _mapSelect = useCallback( mapSelect, deps );\n\n\tconst registry = useRegistry();\n\tconst isAsync = useAsyncMode();\n\n\tconst latestRegistry = useRef( registry );\n\tconst latestMapSelect = useRef();\n\tconst latestIsAsync = useRef( isAsync );\n\tconst latestMapOutput = useRef();\n\tconst latestMapOutputError = useRef();\n\n\t// Keep track of the stores being selected in the `mapSelect` function,\n\t// and only subscribe to those stores later.\n\tconst listeningStores = useRef( [] );\n\tconst wrapSelect = useCallback(\n\t\t( callback ) =>\n\t\t\tregistry.__unstableMarkListeningStores(\n\t\t\t\t() => callback( registry.suspendSelect, registry ),\n\t\t\t\tlisteningStores\n\t\t\t),\n\t\t[ registry ]\n\t);\n\n\t// Generate a \"flag\" for used in the effect dependency array.\n\t// It's different than just using `mapSelect` since deps could be undefined,\n\t// in that case, we would still want to memoize it.\n\tconst depsChangedFlag = useMemo( () => ( {} ), deps || [] );\n\n\tlet mapOutput = latestMapOutput.current;\n\tlet mapOutputError = latestMapOutputError.current;\n\n\tconst hasReplacedRegistry = latestRegistry.current !== registry;\n\tconst hasReplacedMapSelect = latestMapSelect.current !== _mapSelect;\n\tconst hasLeftAsyncMode = latestIsAsync.current && ! isAsync;\n\n\tif ( hasReplacedRegistry || hasReplacedMapSelect || hasLeftAsyncMode ) {\n\t\ttry {\n\t\t\tmapOutput = wrapSelect( _mapSelect );\n\t\t} catch ( error ) {\n\t\t\tmapOutputError = error;\n\t\t}\n\t}\n\n\tuseIsomorphicLayoutEffect( () => {\n\t\tlatestRegistry.current = registry;\n\t\tlatestMapSelect.current = _mapSelect;\n\t\tlatestIsAsync.current = isAsync;\n\t\tlatestMapOutput.current = mapOutput;\n\t\tlatestMapOutputError.current = mapOutputError;\n\t} );\n\n\t// React can sometimes clear the `useMemo` cache.\n\t// We use the cache-stable `useMemoOne` to avoid\n\t// losing queues.\n\tconst queueContext = useMemoOne( () => ( { queue: true } ), [ registry ] );\n\tconst [ , forceRender ] = useReducer( ( s ) => s + 1, 0 );\n\tconst isMounted = useRef( false );\n\n\tuseIsomorphicLayoutEffect( () => {\n\t\tconst onStoreChange = () => {\n\t\t\ttry {\n\t\t\t\tconst newMapOutput = wrapSelect( latestMapSelect.current );\n\n\t\t\t\tif ( isShallowEqual( latestMapOutput.current, newMapOutput ) ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tlatestMapOutput.current = newMapOutput;\n\t\t\t} catch ( error ) {\n\t\t\t\tlatestMapOutputError.current = error;\n\t\t\t}\n\n\t\t\tforceRender();\n\t\t};\n\n\t\tconst onChange = () => {\n\t\t\tif ( ! isMounted.current ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( latestIsAsync.current ) {\n\t\t\t\trenderQueue.add( queueContext, onStoreChange );\n\t\t\t} else {\n\t\t\t\tonStoreChange();\n\t\t\t}\n\t\t};\n\n\t\t// catch any possible state changes during mount before the subscription\n\t\t// could be set.\n\t\tonStoreChange();\n\n\t\tconst unsubscribers = listeningStores.current.map( ( storeName ) =>\n\t\t\tregistry.__unstableSubscribeStore( storeName, onChange )\n\t\t);\n\n\t\tisMounted.current = true;\n\n\t\treturn () => {\n\t\t\t// The return value of the subscribe function could be undefined if the store is a custom generic store.\n\t\t\tunsubscribers.forEach( ( unsubscribe ) => unsubscribe?.() );\n\t\t\trenderQueue.cancel( queueContext );\n\t\t\tisMounted.current = false;\n\t\t};\n\t}, [ registry, wrapSelect, depsChangedFlag ] );\n\n\tif ( mapOutputError ) {\n\t\tthrow mapOutputError;\n\t}\n\n\treturn mapOutput;\n}\n"]}