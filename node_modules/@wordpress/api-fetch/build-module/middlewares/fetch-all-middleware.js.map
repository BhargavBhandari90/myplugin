{"version":3,"sources":["@wordpress/api-fetch/src/middlewares/fetch-all-middleware.js"],"names":["addQueryArgs","apiFetch","modifyQuery","queryArgs","path","url","options","parseResponse","response","json","Promise","reject","parseLinkHeader","linkHeader","match","next","getNextPageUrl","headers","get","requestContainsUnboundedQuery","pathIsUnbounded","indexOf","urlIsUnbounded","fetchAllMiddleware","parse","per_page","results","Array","isArray","nextPage","mergedResults","concat","nextResponse","undefined","nextResults"],"mappings":"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","sourcesContent":["/**\n * WordPress dependencies\n */\nimport { addQueryArgs } from '@wordpress/url';\n\n/**\n * Internal dependencies\n */\nimport apiFetch from '..';\n\n/**\n * Apply query arguments to both URL and Path, whichever is present.\n *\n * @param {import('../types').APIFetchOptions} props\n * @param {Record<string, string | number>}    queryArgs\n * @return {import('../types').APIFetchOptions} The request with the modified query args\n */\nconst modifyQuery = ( { path, url, ...options }, queryArgs ) => ( {\n\t...options,\n\turl: url && addQueryArgs( url, queryArgs ),\n\tpath: path && addQueryArgs( path, queryArgs ),\n} );\n\n/**\n * Duplicates parsing functionality from apiFetch.\n *\n * @param {Response} response\n * @return {Promise<any>} Parsed response json.\n */\nconst parseResponse = ( response ) =>\n\tresponse.json ? response.json() : Promise.reject( response );\n\n/**\n * @param {string | null} linkHeader\n * @return {{ next?: string }} The parsed link header.\n */\nconst parseLinkHeader = ( linkHeader ) => {\n\tif ( ! linkHeader ) {\n\t\treturn {};\n\t}\n\tconst match = linkHeader.match( /<([^>]+)>; rel=\"next\"/ );\n\treturn match\n\t\t? {\n\t\t\t\tnext: match[ 1 ],\n\t\t  }\n\t\t: {};\n};\n\n/**\n * @param {Response} response\n * @return {string | undefined} The next page URL.\n */\nconst getNextPageUrl = ( response ) => {\n\tconst { next } = parseLinkHeader( response.headers.get( 'link' ) );\n\treturn next;\n};\n\n/**\n * @param {import('../types').APIFetchOptions} options\n * @return {boolean} True if the request contains an unbounded query.\n */\nconst requestContainsUnboundedQuery = ( options ) => {\n\tconst pathIsUnbounded =\n\t\t!! options.path && options.path.indexOf( 'per_page=-1' ) !== -1;\n\tconst urlIsUnbounded =\n\t\t!! options.url && options.url.indexOf( 'per_page=-1' ) !== -1;\n\treturn pathIsUnbounded || urlIsUnbounded;\n};\n\n/**\n * The REST API enforces an upper limit on the per_page option. To handle large\n * collections, apiFetch consumers can pass `per_page=-1`; this middleware will\n * then recursively assemble a full response array from all available pages.\n *\n * @type {import('../types').APIFetchMiddleware}\n */\nconst fetchAllMiddleware = async ( options, next ) => {\n\tif ( options.parse === false ) {\n\t\t// If a consumer has opted out of parsing, do not apply middleware.\n\t\treturn next( options );\n\t}\n\tif ( ! requestContainsUnboundedQuery( options ) ) {\n\t\t// If neither url nor path is requesting all items, do not apply middleware.\n\t\treturn next( options );\n\t}\n\n\t// Retrieve requested page of results.\n\tconst response = await apiFetch( {\n\t\t...modifyQuery( options, {\n\t\t\tper_page: 100,\n\t\t} ),\n\t\t// Ensure headers are returned for page 1.\n\t\tparse: false,\n\t} );\n\n\tconst results = await parseResponse( response );\n\n\tif ( ! Array.isArray( results ) ) {\n\t\t// We have no reliable way of merging non-array results.\n\t\treturn results;\n\t}\n\n\tlet nextPage = getNextPageUrl( response );\n\n\tif ( ! nextPage ) {\n\t\t// There are no further pages to request.\n\t\treturn results;\n\t}\n\n\t// Iteratively fetch all remaining pages until no \"next\" header is found.\n\tlet mergedResults = /** @type {any[]} */ ( [] ).concat( results );\n\twhile ( nextPage ) {\n\t\tconst nextResponse = await apiFetch( {\n\t\t\t...options,\n\t\t\t// Ensure the URL for the next page is used instead of any provided path.\n\t\t\tpath: undefined,\n\t\t\turl: nextPage,\n\t\t\t// Ensure we still get headers so we can identify the next page.\n\t\t\tparse: false,\n\t\t} );\n\t\tconst nextResults = await parseResponse( nextResponse );\n\t\tmergedResults = mergedResults.concat( nextResults );\n\t\tnextPage = getNextPageUrl( nextResponse );\n\t}\n\treturn mergedResults;\n};\n\nexport default fetchAllMiddleware;\n"]}