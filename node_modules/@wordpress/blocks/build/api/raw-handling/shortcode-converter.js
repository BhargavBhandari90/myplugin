"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

var _shortcode = require("@wordpress/shortcode");

var _factory = require("../factory");

var _registration = require("../registration");

var _getBlockAttributes = require("../parser/get-block-attributes");

var _applyBuiltInValidationFixes = require("../parser/apply-built-in-validation-fixes");

/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */
function segmentHTMLToShortcodeBlock(HTML) {
  let lastIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  let excludedBlockNames = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
  // Get all matches.
  const transformsFrom = (0, _factory.getBlockTransforms)('from');
  const transformation = (0, _factory.findTransform)(transformsFrom, transform => excludedBlockNames.indexOf(transform.blockName) === -1 && transform.type === 'shortcode' && (0, _lodash.some)((0, _lodash.castArray)(transform.tag), tag => (0, _shortcode.regexp)(tag).test(HTML)));

  if (!transformation) {
    return [HTML];
  }

  const transformTags = (0, _lodash.castArray)(transformation.tag);
  const transformTag = (0, _lodash.find)(transformTags, tag => (0, _shortcode.regexp)(tag).test(HTML));
  let match;
  const previousIndex = lastIndex;

  if (match = (0, _shortcode.next)(transformTag, HTML, lastIndex)) {
    lastIndex = match.index + match.content.length;
    const beforeHTML = HTML.substr(0, match.index);
    const afterHTML = HTML.substr(lastIndex); // If the shortcode content does not contain HTML and the shortcode is
    // not on a new line (or in paragraph from Markdown converter),
    // consider the shortcode as inline text, and thus skip conversion for
    // this segment.

    if (!(0, _lodash.includes)(match.shortcode.content || '', '<') && !(/(\n|<p>)\s*$/.test(beforeHTML) && /^\s*(\n|<\/p>)/.test(afterHTML))) {
      return segmentHTMLToShortcodeBlock(HTML, lastIndex);
    } // If a transformation's `isMatch` predicate fails for the inbound
    // shortcode, try again by excluding the current block type.
    //
    // This is the only call to `segmentHTMLToShortcodeBlock` that should
    // ever carry over `excludedBlockNames`. Other calls in the module
    // should skip that argument as a way to reset the exclusion state, so
    // that one `isMatch` fail in an HTML fragment doesn't prevent any
    // valid matches in subsequent fragments.


    if (transformation.isMatch && !transformation.isMatch(match.shortcode.attrs)) {
      return segmentHTMLToShortcodeBlock(HTML, previousIndex, [...excludedBlockNames, transformation.blockName]);
    }

    const attributes = (0, _lodash.mapValues)((0, _lodash.pickBy)(transformation.attributes, schema => schema.shortcode), // Passing all of `match` as second argument is intentionally broad
    // but shouldn't be too relied upon.
    //
    // See: https://github.com/WordPress/gutenberg/pull/3610#discussion_r152546926
    schema => schema.shortcode(match.shortcode.attrs, match));
    const transformationBlockType = { ...(0, _registration.getBlockType)(transformation.blockName),
      attributes: transformation.attributes
    };
    let block = (0, _factory.createBlock)(transformation.blockName, (0, _getBlockAttributes.getBlockAttributes)(transformationBlockType, match.shortcode.content, attributes));
    block.originalContent = match.shortcode.content; // Applying the built-in fixes can enhance the attributes with missing content like "className".

    block = (0, _applyBuiltInValidationFixes.applyBuiltInValidationFixes)(block, transformationBlockType);
    return [...segmentHTMLToShortcodeBlock(beforeHTML), block, ...segmentHTMLToShortcodeBlock(afterHTML)];
  }

  return [HTML];
}

var _default = segmentHTMLToShortcodeBlock;
exports.default = _default;
//# sourceMappingURL=shortcode-converter.js.map