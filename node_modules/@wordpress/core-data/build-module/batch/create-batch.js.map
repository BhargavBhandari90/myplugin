{"version":3,"sources":["@wordpress/core-data/src/batch/create-batch.js"],"names":["zip","defaultProcessor","createBatch","processor","lastId","queue","pending","ObservableSet","add","inputOrThunk","id","input","Promise","resolve","reject","push","delete","finally","run","size","unsubscribe","subscribe","undefined","results","map","length","Error","error","isSuccess","pair","result","queueItem","output","constructor","args","set","Set","subscribers","value","forEach","subscriber"],"mappings":"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","sourcesContent":["/**\n * External dependencies\n */\nimport { zip } from 'lodash';\n\n/**\n * Internal dependencies\n */\nimport defaultProcessor from './default-processor';\n\n/**\n * Creates a batch, which can be used to combine multiple API requests into one\n * API request using the WordPress batch processing API (/v1/batch).\n *\n * ```\n * const batch = createBatch();\n * const dunePromise = batch.add( {\n *   path: '/v1/books',\n *   method: 'POST',\n *   data: { title: 'Dune' }\n * } );\n * const lotrPromise = batch.add( {\n *   path: '/v1/books',\n *   method: 'POST',\n *   data: { title: 'Lord of the Rings' }\n * } );\n * const isSuccess = await batch.run(); // Sends one POST to /v1/batch.\n * if ( isSuccess ) {\n *   console.log(\n *     'Saved two books:',\n *     await dunePromise,\n *     await lotrPromise\n *   );\n * }\n * ```\n *\n * @param {Function} [processor] Processor function. Can be used to replace the\n *                               default functionality which is to send an API\n *                               request to /v1/batch. Is given an array of\n *                               inputs and must return a promise that\n *                               resolves to an array of objects containing\n *                               either `output` or `error`.\n */\nexport default function createBatch( processor = defaultProcessor ) {\n\tlet lastId = 0;\n\t/** @type {Array<{ input: any; resolve: ( value: any ) => void; reject: ( error: any ) => void }>} */\n\tlet queue = [];\n\tconst pending = new ObservableSet();\n\n\treturn {\n\t\t/**\n\t\t * Adds an input to the batch and returns a promise that is resolved or\n\t\t * rejected when the input is processed by `batch.run()`.\n\t\t *\n\t\t * You may also pass a thunk which allows inputs to be added\n\t\t * asychronously.\n\t\t *\n\t\t * ```\n\t\t * // Both are allowed:\n\t\t * batch.add( { path: '/v1/books', ... } );\n\t\t * batch.add( ( add ) => add( { path: '/v1/books', ... } ) );\n\t\t * ```\n\t\t *\n\t\t * If a thunk is passed, `batch.run()` will pause until either:\n\t\t *\n\t\t * - The thunk calls its `add` argument, or;\n\t\t * - The thunk returns a promise and that promise resolves, or;\n\t\t * - The thunk returns a non-promise.\n\t\t *\n\t\t * @param {any|Function} inputOrThunk Input to add or thunk to execute.\n\t\t *\n\t\t * @return {Promise|any} If given an input, returns a promise that\n\t\t *                       is resolved or rejected when the batch is\n\t\t *                       processed. If given a thunk, returns the return\n\t\t *                       value of that thunk.\n\t\t */\n\t\tadd( inputOrThunk ) {\n\t\t\tconst id = ++lastId;\n\t\t\tpending.add( id );\n\n\t\t\tconst add = ( input ) =>\n\t\t\t\tnew Promise( ( resolve, reject ) => {\n\t\t\t\t\tqueue.push( {\n\t\t\t\t\t\tinput,\n\t\t\t\t\t\tresolve,\n\t\t\t\t\t\treject,\n\t\t\t\t\t} );\n\t\t\t\t\tpending.delete( id );\n\t\t\t\t} );\n\n\t\t\tif ( typeof inputOrThunk === 'function' ) {\n\t\t\t\treturn Promise.resolve( inputOrThunk( add ) ).finally( () => {\n\t\t\t\t\tpending.delete( id );\n\t\t\t\t} );\n\t\t\t}\n\n\t\t\treturn add( inputOrThunk );\n\t\t},\n\n\t\t/**\n\t\t * Runs the batch. This calls `batchProcessor` and resolves or rejects\n\t\t * all promises returned by `add()`.\n\t\t *\n\t\t * @return {Promise<boolean>} A promise that resolves to a boolean that is true\n\t\t *                   if the processor returned no errors.\n\t\t */\n\t\tasync run() {\n\t\t\tif ( pending.size ) {\n\t\t\t\tawait new Promise( ( resolve ) => {\n\t\t\t\t\tconst unsubscribe = pending.subscribe( () => {\n\t\t\t\t\t\tif ( ! pending.size ) {\n\t\t\t\t\t\t\tunsubscribe();\n\t\t\t\t\t\t\tresolve( undefined );\n\t\t\t\t\t\t}\n\t\t\t\t\t} );\n\t\t\t\t} );\n\t\t\t}\n\n\t\t\tlet results;\n\n\t\t\ttry {\n\t\t\t\tresults = await processor(\n\t\t\t\t\tqueue.map( ( { input } ) => input )\n\t\t\t\t);\n\n\t\t\t\tif ( results.length !== queue.length ) {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t'run: Array returned by processor must be same size as input array.'\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t} catch ( error ) {\n\t\t\t\tfor ( const { reject } of queue ) {\n\t\t\t\t\treject( error );\n\t\t\t\t}\n\n\t\t\t\tthrow error;\n\t\t\t}\n\n\t\t\tlet isSuccess = true;\n\n\t\t\tfor ( const pair of zip( results, queue ) ) {\n\t\t\t\t/** @type {{error?: unknown, output?: unknown}} */\n\t\t\t\tconst result = pair[ 0 ];\n\n\t\t\t\t/** @type {{resolve: (value: any) => void; reject: (error: any) => void} | undefined} */\n\t\t\t\tconst queueItem = pair[ 1 ];\n\n\t\t\t\tif ( result?.error ) {\n\t\t\t\t\tqueueItem?.reject( result.error );\n\t\t\t\t\tisSuccess = false;\n\t\t\t\t} else {\n\t\t\t\t\tqueueItem?.resolve( result?.output ?? result );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tqueue = [];\n\n\t\t\treturn isSuccess;\n\t\t},\n\t};\n}\n\nclass ObservableSet {\n\tconstructor( ...args ) {\n\t\tthis.set = new Set( ...args );\n\t\tthis.subscribers = new Set();\n\t}\n\n\tget size() {\n\t\treturn this.set.size;\n\t}\n\n\tadd( value ) {\n\t\tthis.set.add( value );\n\t\tthis.subscribers.forEach( ( subscriber ) => subscriber() );\n\t\treturn this;\n\t}\n\n\tdelete( value ) {\n\t\tconst isSuccess = this.set.delete( value );\n\t\tthis.subscribers.forEach( ( subscriber ) => subscriber() );\n\t\treturn isSuccess;\n\t}\n\n\tsubscribe( subscriber ) {\n\t\tthis.subscribers.add( subscriber );\n\t\treturn () => {\n\t\t\tthis.subscribers.delete( subscriber );\n\t\t};\n\t}\n}\n"]}