{"version":3,"sources":["@wordpress/core-data/src/queried-data/reducer.js"],"names":["map","flowRight","omit","filter","mapValues","combineReducers","conservativeMapItem","ifMatchingAction","replaceAction","onSubKey","DEFAULT_ENTITY_KEY","getQueryParts","getContextFromAction","action","query","queryParts","context","getMergedItemIds","itemIds","nextItemIds","page","perPage","receivedAllIds","nextItemIdsStartIndex","size","Math","max","length","mergedItemIds","Array","i","isInNextItemsRange","items","state","type","key","reduce","accumulator","value","itemId","contextState","itemIsComplete","isCompleteQuery","isArray","fields","result","item","receiveQueries","queries","removedItems","contextQueries","queryItems","queryId"],"mappings":"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","sourcesContent":["/**\n * External dependencies\n */\nimport { map, flowRight, omit, filter, mapValues } from 'lodash';\n\n/**\n * WordPress dependencies\n */\nimport { combineReducers } from '@wordpress/data';\n\n/**\n * Internal dependencies\n */\nimport {\n\tconservativeMapItem,\n\tifMatchingAction,\n\treplaceAction,\n\tonSubKey,\n} from '../utils';\nimport { DEFAULT_ENTITY_KEY } from '../entities';\nimport getQueryParts from './get-query-parts';\n\nfunction getContextFromAction( action ) {\n\tconst { query } = action;\n\tif ( ! query ) {\n\t\treturn 'default';\n\t}\n\n\tconst queryParts = getQueryParts( query );\n\treturn queryParts.context;\n}\n\n/**\n * Returns a merged array of item IDs, given details of the received paginated\n * items. The array is sparse-like with `undefined` entries where holes exist.\n *\n * @param {?Array<number>} itemIds     Original item IDs (default empty array).\n * @param {number[]}       nextItemIds Item IDs to merge.\n * @param {number}         page        Page of items merged.\n * @param {number}         perPage     Number of items per page.\n *\n * @return {number[]} Merged array of item IDs.\n */\nexport function getMergedItemIds( itemIds, nextItemIds, page, perPage ) {\n\tconst receivedAllIds = page === 1 && perPage === -1;\n\tif ( receivedAllIds ) {\n\t\treturn nextItemIds;\n\t}\n\tconst nextItemIdsStartIndex = ( page - 1 ) * perPage;\n\n\t// If later page has already been received, default to the larger known\n\t// size of the existing array, else calculate as extending the existing.\n\tconst size = Math.max(\n\t\titemIds?.length ?? 0,\n\t\tnextItemIdsStartIndex + nextItemIds.length\n\t);\n\n\t// Preallocate array since size is known.\n\tconst mergedItemIds = new Array( size );\n\n\tfor ( let i = 0; i < size; i++ ) {\n\t\t// Preserve existing item ID except for subset of range of next items.\n\t\tconst isInNextItemsRange =\n\t\t\ti >= nextItemIdsStartIndex &&\n\t\t\ti < nextItemIdsStartIndex + nextItemIds.length;\n\n\t\tmergedItemIds[ i ] = isInNextItemsRange\n\t\t\t? nextItemIds[ i - nextItemIdsStartIndex ]\n\t\t\t: itemIds?.[ i ];\n\t}\n\n\treturn mergedItemIds;\n}\n\n/**\n * Reducer tracking items state, keyed by ID. Items are assumed to be normal,\n * where identifiers are common across all queries.\n *\n * @param {Object} state  Current state.\n * @param {Object} action Dispatched action.\n *\n * @return {Object} Next state.\n */\nexport function items( state = {}, action ) {\n\tswitch ( action.type ) {\n\t\tcase 'RECEIVE_ITEMS': {\n\t\t\tconst context = getContextFromAction( action );\n\t\t\tconst key = action.key || DEFAULT_ENTITY_KEY;\n\t\t\treturn {\n\t\t\t\t...state,\n\t\t\t\t[ context ]: {\n\t\t\t\t\t...state[ context ],\n\t\t\t\t\t...action.items.reduce( ( accumulator, value ) => {\n\t\t\t\t\t\tconst itemId = value[ key ];\n\t\t\t\t\t\taccumulator[ itemId ] = conservativeMapItem(\n\t\t\t\t\t\t\tstate?.[ context ]?.[ itemId ],\n\t\t\t\t\t\t\tvalue\n\t\t\t\t\t\t);\n\t\t\t\t\t\treturn accumulator;\n\t\t\t\t\t}, {} ),\n\t\t\t\t},\n\t\t\t};\n\t\t}\n\t\tcase 'REMOVE_ITEMS':\n\t\t\treturn mapValues( state, ( contextState ) =>\n\t\t\t\tomit( contextState, action.itemIds )\n\t\t\t);\n\t}\n\treturn state;\n}\n\n/**\n * Reducer tracking item completeness, keyed by ID. A complete item is one for\n * which all fields are known. This is used in supporting `_fields` queries,\n * where not all properties associated with an entity are necessarily returned.\n * In such cases, completeness is used as an indication of whether it would be\n * safe to use queried data for a non-`_fields`-limited request.\n *\n * @param {Object<string,Object<string,boolean>>} state  Current state.\n * @param {Object}                                action Dispatched action.\n *\n * @return {Object<string,Object<string,boolean>>} Next state.\n */\nexport function itemIsComplete( state = {}, action ) {\n\tswitch ( action.type ) {\n\t\tcase 'RECEIVE_ITEMS': {\n\t\t\tconst context = getContextFromAction( action );\n\t\t\tconst { query, key = DEFAULT_ENTITY_KEY } = action;\n\n\t\t\t// An item is considered complete if it is received without an associated\n\t\t\t// fields query. Ideally, this would be implemented in such a way where the\n\t\t\t// complete aggregate of all fields would satisfy completeness. Since the\n\t\t\t// fields are not consistent across all entities, this would require\n\t\t\t// introspection on the REST schema for each entity to know which fields\n\t\t\t// compose a complete item for that entity.\n\t\t\tconst queryParts = query ? getQueryParts( query ) : {};\n\t\t\tconst isCompleteQuery =\n\t\t\t\t! query || ! Array.isArray( queryParts.fields );\n\n\t\t\treturn {\n\t\t\t\t...state,\n\t\t\t\t[ context ]: {\n\t\t\t\t\t...state[ context ],\n\t\t\t\t\t...action.items.reduce( ( result, item ) => {\n\t\t\t\t\t\tconst itemId = item[ key ];\n\n\t\t\t\t\t\t// Defer to completeness if already assigned. Technically the\n\t\t\t\t\t\t// data may be outdated if receiving items for a field subset.\n\t\t\t\t\t\tresult[ itemId ] =\n\t\t\t\t\t\t\tstate?.[ context ]?.[ itemId ] || isCompleteQuery;\n\n\t\t\t\t\t\treturn result;\n\t\t\t\t\t}, {} ),\n\t\t\t\t},\n\t\t\t};\n\t\t}\n\t\tcase 'REMOVE_ITEMS':\n\t\t\treturn mapValues( state, ( contextState ) =>\n\t\t\t\tomit( contextState, action.itemIds )\n\t\t\t);\n\t}\n\n\treturn state;\n}\n\n/**\n * Reducer tracking queries state, keyed by stable query key. Each reducer\n * query object includes `itemIds` and `requestingPageByPerPage`.\n *\n * @param {Object} state  Current state.\n * @param {Object} action Dispatched action.\n *\n * @return {Object} Next state.\n */\nconst receiveQueries = flowRight( [\n\t// Limit to matching action type so we don't attempt to replace action on\n\t// an unhandled action.\n\tifMatchingAction( ( action ) => 'query' in action ),\n\n\t// Inject query parts into action for use both in `onSubKey` and reducer.\n\treplaceAction( ( action ) => {\n\t\t// `ifMatchingAction` still passes on initialization, where state is\n\t\t// undefined and a query is not assigned. Avoid attempting to parse\n\t\t// parts. `onSubKey` will omit by lack of `stableKey`.\n\t\tif ( action.query ) {\n\t\t\treturn {\n\t\t\t\t...action,\n\t\t\t\t...getQueryParts( action.query ),\n\t\t\t};\n\t\t}\n\n\t\treturn action;\n\t} ),\n\n\tonSubKey( 'context' ),\n\n\t// Queries shape is shared, but keyed by query `stableKey` part. Original\n\t// reducer tracks only a single query object.\n\tonSubKey( 'stableKey' ),\n] )( ( state = null, action ) => {\n\tconst { type, page, perPage, key = DEFAULT_ENTITY_KEY } = action;\n\n\tif ( type !== 'RECEIVE_ITEMS' ) {\n\t\treturn state;\n\t}\n\n\treturn getMergedItemIds(\n\t\tstate || [],\n\t\tmap( action.items, key ),\n\t\tpage,\n\t\tperPage\n\t);\n} );\n\n/**\n * Reducer tracking queries state.\n *\n * @param {Object} state  Current state.\n * @param {Object} action Dispatched action.\n *\n * @return {Object} Next state.\n */\nconst queries = ( state = {}, action ) => {\n\tswitch ( action.type ) {\n\t\tcase 'RECEIVE_ITEMS':\n\t\t\treturn receiveQueries( state, action );\n\t\tcase 'REMOVE_ITEMS':\n\t\t\tconst removedItems = action.itemIds.reduce( ( result, itemId ) => {\n\t\t\t\tresult[ itemId ] = true;\n\t\t\t\treturn result;\n\t\t\t}, {} );\n\n\t\t\treturn mapValues( state, ( contextQueries ) => {\n\t\t\t\treturn mapValues( contextQueries, ( queryItems ) => {\n\t\t\t\t\treturn filter( queryItems, ( queryId ) => {\n\t\t\t\t\t\treturn ! removedItems[ queryId ];\n\t\t\t\t\t} );\n\t\t\t\t} );\n\t\t\t} );\n\t\tdefault:\n\t\t\treturn state;\n\t}\n};\n\nexport default combineReducers( {\n\titems,\n\titemIsComplete,\n\tqueries,\n} );\n"]}