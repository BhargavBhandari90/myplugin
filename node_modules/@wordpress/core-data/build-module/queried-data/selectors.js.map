{"version":3,"sources":["@wordpress/core-data/src/queried-data/selectors.js"],"names":["createSelector","EquivalentKeyMap","get","set","getQueryParts","queriedItemsCacheByState","WeakMap","getQueriedItemsUncached","state","query","stableKey","page","perPage","include","fields","context","itemIds","queries","startOffset","endOffset","length","Math","min","items","i","itemId","Array","isArray","includes","hasOwnProperty","item","filteredItem","f","field","split","value","itemIsComplete","push","getQueriedItems","queriedItemsCache","queriedItems","undefined"],"mappings":"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","sourcesContent":["/**\n * External dependencies\n */\nimport createSelector from 'rememo';\nimport EquivalentKeyMap from 'equivalent-key-map';\nimport { get, set } from 'lodash';\n\n/**\n * Internal dependencies\n */\nimport getQueryParts from './get-query-parts';\n\n/**\n * Cache of state keys to EquivalentKeyMap where the inner map tracks queries\n * to their resulting items set. WeakMap allows garbage collection on expired\n * state references.\n *\n * @type {WeakMap<Object,EquivalentKeyMap>}\n */\nconst queriedItemsCacheByState = new WeakMap();\n\n/**\n * Returns items for a given query, or null if the items are not known.\n *\n * @param {Object}  state State object.\n * @param {?Object} query Optional query.\n *\n * @return {?Array} Query items.\n */\nfunction getQueriedItemsUncached( state, query ) {\n\tconst { stableKey, page, perPage, include, fields, context } =\n\t\tgetQueryParts( query );\n\tlet itemIds;\n\n\tif ( state.queries?.[ context ]?.[ stableKey ] ) {\n\t\titemIds = state.queries[ context ][ stableKey ];\n\t}\n\n\tif ( ! itemIds ) {\n\t\treturn null;\n\t}\n\n\tconst startOffset = perPage === -1 ? 0 : ( page - 1 ) * perPage;\n\tconst endOffset =\n\t\tperPage === -1\n\t\t\t? itemIds.length\n\t\t\t: Math.min( startOffset + perPage, itemIds.length );\n\n\tconst items = [];\n\tfor ( let i = startOffset; i < endOffset; i++ ) {\n\t\tconst itemId = itemIds[ i ];\n\t\tif ( Array.isArray( include ) && ! include.includes( itemId ) ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Having a target item ID doesn't guarantee that this object has been queried.\n\t\tif ( ! state.items[ context ]?.hasOwnProperty( itemId ) ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst item = state.items[ context ][ itemId ];\n\n\t\tlet filteredItem;\n\t\tif ( Array.isArray( fields ) ) {\n\t\t\tfilteredItem = {};\n\n\t\t\tfor ( let f = 0; f < fields.length; f++ ) {\n\t\t\t\tconst field = fields[ f ].split( '.' );\n\t\t\t\tconst value = get( item, field );\n\t\t\t\tset( filteredItem, field, value );\n\t\t\t}\n\t\t} else {\n\t\t\t// If expecting a complete item, validate that completeness, or\n\t\t\t// otherwise abort.\n\t\t\tif ( ! state.itemIsComplete[ context ]?.[ itemId ] ) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tfilteredItem = item;\n\t\t}\n\n\t\titems.push( filteredItem );\n\t}\n\n\treturn items;\n}\n\n/**\n * Returns items for a given query, or null if the items are not known. Caches\n * result both per state (by reference) and per query (by deep equality).\n * The caching approach is intended to be durable to query objects which are\n * deeply but not referentially equal, since otherwise:\n *\n * `getQueriedItems( state, {} ) !== getQueriedItems( state, {} )`\n *\n * @param {Object}  state State object.\n * @param {?Object} query Optional query.\n *\n * @return {?Array} Query items.\n */\nexport const getQueriedItems = createSelector( ( state, query = {} ) => {\n\tlet queriedItemsCache = queriedItemsCacheByState.get( state );\n\tif ( queriedItemsCache ) {\n\t\tconst queriedItems = queriedItemsCache.get( query );\n\t\tif ( queriedItems !== undefined ) {\n\t\t\treturn queriedItems;\n\t\t}\n\t} else {\n\t\tqueriedItemsCache = new EquivalentKeyMap();\n\t\tqueriedItemsCacheByState.set( state, queriedItemsCache );\n\t}\n\n\tconst items = getQueriedItemsUncached( state, query );\n\tqueriedItemsCache.set( query, items );\n\treturn items;\n} );\n"]}