"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.META_SELECTORS = void 0;
exports.default = __experimentalUseQuerySelect;

var _data = require("@wordpress/data");

var _memoize = _interopRequireDefault(require("./memoize"));

var _constants = require("./constants");

/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */
const META_SELECTORS = ['getIsResolving', 'hasStartedResolution', 'hasFinishedResolution', 'isResolving', 'getCachedResolvers'];
exports.META_SELECTORS = META_SELECTORS;

/**
 * Like useSelect, but the selectors return objects containing
 * both the original data AND the resolution info.
 *
 * @param {Function} mapQuerySelect see useSelect
 * @param {Array}    deps           see useSelect
 *
 * @example
 * ```js
 * import { useQuerySelect } from '@wordpress/data';
 * import { store as coreDataStore } from '@wordpress/core-data';
 *
 * function PageTitleDisplay( { id } ) {
 *   const { data: page, isResolving } = useQuerySelect( ( query ) => {
 *     return query( coreDataStore ).getEntityRecord( 'postType', 'page', id )
 *   }, [ id ] );
 *
 *   if ( isResolving ) {
 *     return 'Loading...';
 *   }
 *
 *   return page.title;
 * }
 *
 * // Rendered in the application:
 * // <PageTitleDisplay id={ 10 } />
 * ```
 *
 * In the above example, when `PageTitleDisplay` is rendered into an
 * application, the page and the resolution details will be retrieved from
 * the store state using the `mapSelect` callback on `useQuerySelect`.
 *
 * If the id prop changes then any page in the state for that id is
 * retrieved. If the id prop doesn't change and other props are passed in
 * that do change, the title will not change because the dependency is just
 * the id.
 * @see useSelect
 *
 * @return {QuerySelectResponse} Queried data.
 */
function __experimentalUseQuerySelect(mapQuerySelect, deps) {
  return (0, _data.useSelect)((select, registry) => {
    const resolve = store => enrichSelectors(select(store));

    return mapQuerySelect(resolve, registry);
  }, deps);
}

/**
 * Transform simple selectors into ones that return an object with the
 * original return value AND the resolution info.
 *
 * @param {Object} selectors Selectors to enrich
 * @return {EnrichedSelectors} Enriched selectors
 */
const enrichSelectors = (0, _memoize.default)(selectors => {
  const resolvers = {};

  for (const selectorName in selectors) {
    if (META_SELECTORS.includes(selectorName)) {
      continue;
    }

    Object.defineProperty(resolvers, selectorName, {
      get: () => function () {
        const {
          getIsResolving,
          hasFinishedResolution
        } = selectors;

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        const isResolving = !!getIsResolving(selectorName, args);
        const hasResolved = !isResolving && hasFinishedResolution(selectorName, args);
        const data = selectors[selectorName](...args);
        let status;

        if (isResolving) {
          status = _constants.Status.Resolving;
        } else if (hasResolved) {
          if (data) {
            status = _constants.Status.Success;
          } else {
            status = _constants.Status.Error;
          }
        } else {
          status = _constants.Status.Idle;
        }

        return {
          data,
          status,
          isResolving,
          hasResolved
        };
      }
    });
  }

  return resolvers;
});
//# sourceMappingURL=use-query-select.js.map