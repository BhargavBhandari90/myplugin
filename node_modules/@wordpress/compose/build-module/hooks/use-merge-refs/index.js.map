{"version":3,"sources":["@wordpress/compose/src/hooks/use-merge-refs/index.js"],"names":["useRef","useCallback","useLayoutEffect","assignRef","ref","value","hasOwnProperty","current","useMergeRefs","refs","element","didElementChange","previousRefs","currentRefs","forEach","index","previousRef","refsToAssign"],"mappings":"AAAA;AACA;AACA;AACA,SAASA,MAAT,EAAiBC,WAAjB,EAA8BC,eAA9B,QAAqD,oBAArD;AAEA;;AACA;AACA;AACA;AACA;;AACA;;AAEA;AACA;AACA;AACA;AACA;;AACA,SAASC,SAAT,CAAoBC,GAApB,EAAyBC,KAAzB,EAAiC;AAChC,MAAK,OAAOD,GAAP,KAAe,UAApB,EAAiC;AAChCA,IAAAA,GAAG,CAAEC,KAAF,CAAH;AACA,GAFD,MAEO,IAAKD,GAAG,IAAIA,GAAG,CAACE,cAAJ,CAAoB,SAApB,CAAZ,EAA8C;AACpD;;AACA;AAAqDF,IAAAA,GAAF,CAAQG,OAAR,GAClDF,KADkD;AAEnD;AACA;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,eAAe,SAASG,YAAT,CAAuBC,IAAvB,EAA8B;AAC5C,QAAMC,OAAO,GAAGV,MAAM,EAAtB;AACA,QAAMW,gBAAgB,GAAGX,MAAM,CAAE,KAAF,CAA/B;AACA;;AACA;;AACA;;AACA,QAAMY,YAAY,GAAGZ,MAAM,CAAE,EAAF,CAA3B;AACA,QAAMa,WAAW,GAAGb,MAAM,CAAES,IAAF,CAA1B,CAP4C,CAS5C;AACA;;AACAI,EAAAA,WAAW,CAACN,OAAZ,GAAsBE,IAAtB,CAX4C,CAa5C;AACA;AACA;;AACAP,EAAAA,eAAe,CAAE,MAAM;AACtB,QAAKS,gBAAgB,CAACJ,OAAjB,KAA6B,KAAlC,EAA0C;AACzCE,MAAAA,IAAI,CAACK,OAAL,CAAc,CAAEV,GAAF,EAAOW,KAAP,KAAkB;AAC/B,cAAMC,WAAW,GAAGJ,YAAY,CAACL,OAAb,CAAsBQ,KAAtB,CAApB;;AACA,YAAKX,GAAG,KAAKY,WAAb,EAA2B;AAC1Bb,UAAAA,SAAS,CAAEa,WAAF,EAAe,IAAf,CAAT;AACAb,UAAAA,SAAS,CAAEC,GAAF,EAAOM,OAAO,CAACH,OAAf,CAAT;AACA;AACD,OAND;AAOA;;AAEDK,IAAAA,YAAY,CAACL,OAAb,GAAuBE,IAAvB;AACA,GAZc,EAYZA,IAZY,CAAf,CAhB4C,CA8B5C;AACA;;AACAP,EAAAA,eAAe,CAAE,MAAM;AACtBS,IAAAA,gBAAgB,CAACJ,OAAjB,GAA2B,KAA3B;AACA,GAFc,CAAf,CAhC4C,CAoC5C;AACA;;AACA,SAAON,WAAW,CAAII,KAAF,IAAa;AAChC;AACA;AACAF,IAAAA,SAAS,CAAEO,OAAF,EAAWL,KAAX,CAAT;AAEAM,IAAAA,gBAAgB,CAACJ,OAAjB,GAA2B,IAA3B,CALgC,CAOhC;AACA;;AACA,UAAMU,YAAY,GAAGZ,KAAK,GAAGQ,WAAW,CAACN,OAAf,GAAyBK,YAAY,CAACL,OAAhE,CATgC,CAWhC;;AACA,SAAM,MAAMH,GAAZ,IAAmBa,YAAnB,EAAkC;AACjCd,MAAAA,SAAS,CAAEC,GAAF,EAAOC,KAAP,CAAT;AACA;AACD,GAfiB,EAef,EAfe,CAAlB;AAgBA","sourcesContent":["/**\n * WordPress dependencies\n */\nimport { useRef, useCallback, useLayoutEffect } from '@wordpress/element';\n\n/* eslint-disable jsdoc/valid-types */\n/**\n * @template T\n * @typedef {T extends import('react').Ref<infer R> ? R : never} TypeFromRef\n */\n/* eslint-enable jsdoc/valid-types */\n\n/**\n * @template T\n * @param {import('react').Ref<T>} ref\n * @param {T}                      value\n */\nfunction assignRef( ref, value ) {\n\tif ( typeof ref === 'function' ) {\n\t\tref( value );\n\t} else if ( ref && ref.hasOwnProperty( 'current' ) ) {\n\t\t/* eslint-disable jsdoc/no-undefined-types */\n\t\t/** @type {import('react').MutableRefObject<T>} */ ( ref ).current =\n\t\t\tvalue;\n\t\t/* eslint-enable jsdoc/no-undefined-types */\n\t}\n}\n\n/**\n * Merges refs into one ref callback.\n *\n * It also ensures that the merged ref callbacks are only called when they\n * change (as a result of a `useCallback` dependency update) OR when the ref\n * value changes, just as React does when passing a single ref callback to the\n * component.\n *\n * As expected, if you pass a new function on every render, the ref callback\n * will be called after every render.\n *\n * If you don't wish a ref callback to be called after every render, wrap it\n * with `useCallback( callback, dependencies )`. When a dependency changes, the\n * old ref callback will be called with `null` and the new ref callback will be\n * called with the same value.\n *\n * To make ref callbacks easier to use, you can also pass the result of\n * `useRefEffect`, which makes cleanup easier by allowing you to return a\n * cleanup function instead of handling `null`.\n *\n * It's also possible to _disable_ a ref (and its behaviour) by simply not\n * passing the ref.\n *\n * ```jsx\n * const ref = useRefEffect( ( node ) => {\n *   node.addEventListener( ... );\n *   return () => {\n *     node.removeEventListener( ... );\n *   };\n * }, [ ...dependencies ] );\n * const otherRef = useRef();\n * const mergedRefs useMergeRefs( [\n *   enabled && ref,\n *   otherRef,\n * ] );\n * return <div ref={ mergedRefs } />;\n * ```\n *\n * @template {import('react').Ref<any>} TRef\n * @param {Array<TRef>} refs The refs to be merged.\n *\n * @return {import('react').RefCallback<TypeFromRef<TRef>>} The merged ref callback.\n */\nexport default function useMergeRefs( refs ) {\n\tconst element = useRef();\n\tconst didElementChange = useRef( false );\n\t/* eslint-disable jsdoc/no-undefined-types */\n\t/** @type {import('react').MutableRefObject<TRef[]>} */\n\t/* eslint-enable jsdoc/no-undefined-types */\n\tconst previousRefs = useRef( [] );\n\tconst currentRefs = useRef( refs );\n\n\t// Update on render before the ref callback is called, so the ref callback\n\t// always has access to the current refs.\n\tcurrentRefs.current = refs;\n\n\t// If any of the refs change, call the previous ref with `null` and the new\n\t// ref with the node, except when the element changes in the same cycle, in\n\t// which case the ref callbacks will already have been called.\n\tuseLayoutEffect( () => {\n\t\tif ( didElementChange.current === false ) {\n\t\t\trefs.forEach( ( ref, index ) => {\n\t\t\t\tconst previousRef = previousRefs.current[ index ];\n\t\t\t\tif ( ref !== previousRef ) {\n\t\t\t\t\tassignRef( previousRef, null );\n\t\t\t\t\tassignRef( ref, element.current );\n\t\t\t\t}\n\t\t\t} );\n\t\t}\n\n\t\tpreviousRefs.current = refs;\n\t}, refs );\n\n\t// No dependencies, must be reset after every render so ref callbacks are\n\t// correctly called after a ref change.\n\tuseLayoutEffect( () => {\n\t\tdidElementChange.current = false;\n\t} );\n\n\t// There should be no dependencies so that `callback` is only called when\n\t// the node changes.\n\treturn useCallback( ( value ) => {\n\t\t// Update the element so it can be used when calling ref callbacks on a\n\t\t// dependency change.\n\t\tassignRef( element, value );\n\n\t\tdidElementChange.current = true;\n\n\t\t// When an element changes, the current ref callback should be called\n\t\t// with the new element and the previous one with `null`.\n\t\tconst refsToAssign = value ? currentRefs.current : previousRefs.current;\n\n\t\t// Update the latest refs.\n\t\tfor ( const ref of refsToAssign ) {\n\t\t\tassignRef( ref, value );\n\t\t}\n\t}, [] );\n}\n"]}